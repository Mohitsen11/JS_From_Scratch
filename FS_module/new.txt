TRANSFORMSTREAM
THE TRANSFORMSTREAM INTERFACE OF THE STREAMS API REPRESENTS A CONCRETE IMPLEMENTATION OF THE PIPE CHAIN TRANSFORM STREAM CONCEPT.

IT MAY BE PASSED TO THE READABLESTREAM.PIPETHROUGH() METHOD IN ORDER TO TRANSFORM A STREAM OF DATA FROM ONE FORMAT INTO ANOTHER. FOR EXAMPLE, IT MIGHT BE USED TO DECODE (OR ENCODE) VIDEO FRAMES, DECOMPRESS DATA, OR CONVERT THE STREAM FROM XML TO JSON.

A TRANSFORMATION ALGORITHM MAY BE PROVIDED AS AN OPTIONAL ARGUMENT TO THE OBJECT CONSTRUCTOR. IF NOT SUPPLIED, DATA IS NOT MODIFIED WHEN PIPED THROUGH THE STREAM.

TRANSFORMSTREAM IS A TRANSFERABLE OBJECT.

CONSTRUCTOR
TRANSFORMSTREAM()
CREATES AND RETURNS A TRANSFORM STREAM OBJECT, OPTIONALLY SPECIFYING A TRANSFORMATION OBJECT AND QUEUING STRATEGIES FOR THE STREAMS.

INSTANCE PROPERTIES
TRANSFORMSTREAM.READABLE READ ONLY
THE READABLE END OF A TRANSFORMSTREAM.

TRANSFORMSTREAM.WRITABLE READ ONLY
THE WRITABLE END OF A TRANSFORMSTREAM.

INSTANCE METHODS
NONE

EXAMPLES
ANYTHING-TO-UINT8ARRAY STREAM
IN THE FOLLOWING EXAMPLE, A TRANSFORM STREAM PASSES THROUGH ALL CHUNKS IT RECEIVES AS UINT8ARRAY VALUES.

JS
COPY TO CLIPBOARD
CONST TRANSFORMCONTENT = {
  START() {}, // REQUIRED.
  ASYNC TRANSFORM(CHUNK, CONTROLLER) {
    CHUNK = AWAIT CHUNK;
    SWITCH (TYPEOF CHUNK) {
      CASE "OBJECT":
        // JUST SAY THE STREAM IS DONE I GUESS
        IF (CHUNK === NULL) {
          CONTROLLER.TERMINATE();
        } ELSE IF (ARRAYBUFFER.ISVIEW(CHUNK)) {
          CONTROLLER.ENQUEUE(
            NEW UINT8ARRAY(CHUNK.BUFFER, CHUNK.BYTEOFFSET, CHUNK.BYTELENGTH),
          );
        } ELSE IF (
          ARRAY.ISARRAY(CHUNK) &&
          CHUNK.EVERY((VALUE) => TYPEOF VALUE === "NUMBER")
        ) {
          CONTROLLER.ENQUEUE(NEW UINT8ARRAY(CHUNK));
        } ELSE IF (
          TYPEOF CHUNK.VALUEOF === "FUNCTION" &&
          CHUNK.VALUEOF() !== CHUNK
        ) {
          THIS.TRANSFORM(CHUNK.VALUEOF(), CONTROLLER); // HACK
        } ELSE IF ("TOJSON" IN CHUNK) {
          THIS.TRANSFORM(JSON.STRINGIFY(CHUNK), CONTROLLER);
        }
        BREAK;
      CASE "SYMBOL":
        CONTROLLER.ERROR("CANNOT SEND A SYMBOL AS A CHUNK PART");
        BREAK;
      CASE "UNDEFINED":
        CONTROLLER.ERROR("CANNOT SEND UNDEFINED AS A CHUNK PART");
        BREAK;
      DEFAULT:
        CONTROLLER.ENQUEUE(THIS.TEXTENCODER.ENCODE(STRING(CHUNK)));
        BREAK;
    }
  },
  FLUSH() {
    /* DO ANY DESTRUCTOR WORK HERE */
  },
};

CLASS ANYTOU8STREAM EXTENDS TRANSFORMSTREAM {
  CONSTRUCTOR() {
    SUPER({ ...TRANSFORMCONTENT, TEXTENCODER: NEW TEXTENCODER() });
  }
}
POLYFILLING TEXTENCODERSTREAM AND TEXTDECODERSTREAM
NOTE THAT THIS IS DEPRECATED BY THE NATIVE CONSTRUCTORS. THIS IS INTENDED AS A POLYFILL FOR UNSUPPORTED PLATFORMS.

JS
COPY TO CLIPBOARD
CONST TES = {
  START() {
    THIS.ENCODER = NEW TEXTENCODER();
  },
  TRANSFORM(CHUNK, CONTROLLER) {
    CONTROLLER.ENQUEUE(THIS.ENCODER.ENCODE(CHUNK));
  },
};

LET _JSTES_WM = NEW WEAKMAP(); /* INFO HOLDER */
CLASS JSTEXTENCODERSTREAM EXTENDS TRANSFORMSTREAM {
  CONSTRUCTOR() {
    LET T = { ...TES };

    SUPER(T);
    _JSTES_WM.SET(THIS, T);
  }
  GET ENCODING() {
    RETURN _JSTES_WM.GET(THIS).ENCODER.ENCODING;
  }
}
SIMILARLY, TEXTDECODERSTREAM CAN BE WRITTEN AS SUCH:

JS
COPY TO CLIPBOARD
CONST TDS = {
  START() {
    THIS.DECODER = NEW TEXTDECODER(THIS.ENCODING, THIS.OPTIONS);
  },
  TRANSFORM(CHUNK, CONTROLLER) {
    CONTROLLER.ENQUEUE(THIS.DECODER.DECODE(CHUNK, { STREAM: TRUE }));
  },
};

LET _JSTDS_WM = NEW WEAKMAP(); /* INFO HOLDER */
CLASS JSTEXTDECODERSTREAM EXTENDS TRANSFORMSTREAM {
  CONSTRUCTOR(ENCODING = "UTF-8", { ...OPTIONS } = {}) {
    LET T = { ...TDS, ENCODING, OPTIONS };

    SUPER(T);
    _JSTDS_WM.SET(THIS, T);
  }
  GET ENCODING() {
    RETURN _JSTDS_WM.GET(THIS).DECODER.ENCODING;
  }
  GET FATAL() {
    RETURN _JSTDS_WM.GET(THIS).DECODER.FATAL;
  }
  GET IGNOREBOM() {
    RETURN _JSTDS_WM.GET(THIS).DECODER.IGNOREBOM;
  }
}
CHAINING MULTIPLE READABLESTREAMS TOGETHER
THIS IS A USEFUL ONE, WHERE MULTIPLE STREAMS CAN BE CONJOINED. EXAMPLES INCLUDE BUILDING A PWA WITH PROGRESSIVE LOADING AND PROGRESSIVE STREAMING.

JS
COPY TO CLIPBOARD
LET RESPONSES = [
  /* CONJOINED RESPONSE TREE */
];
LET { READABLE, WRITABLE } = NEW TRANSFORMSTREAM();

RESPONSES.REDUCE(
  (A, RES, I, ARR) =>
    A.THEN(() => RES.PIPETO(WRITABLE, { PREVENTCLOSE: I + 1 !== ARR.LENGTH })),
  PROMISE.RESOLVE(),
);
NOTE THAT THIS IS NOT RESILIENT TO OTHER INFLUENCES.